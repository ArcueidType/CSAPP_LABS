# CSAPP Lab2 BombLab
## 解题思路
### Phase_1:
Phase_1要求输入正确的字符串

![Phase_1](./img/Phase_1.png)

通过Phase_1的汇编代码我们发现，其调用了`string_not_equal`函数

该函数的作用是判断两个字符串是否相同，若相同则返回0，否则返回1(对string_not_equal分析，假设两个字符串相同，不难发现返回值，此处省略详细代码)

我们注意到，过程中向`%rsi`载入了一个值，表达方式是`%rip`的偏移，说明这是一个全局变量，右边#后的值即为绝对地址

`%rsi`是函数的第二个参数，说明`string_not_equal`的第一个参数`%rdi`即指向我们输入的字符串

所以只要查看上述绝对地址处储存的字符串就可以得到Phase_1的答案

![Phase_1_ans](./img/Phase_1_ans.png)

通过x指令查看字符串内容，我们就得到了Phase_1的答案:

**I am not part of the problem. I am a Republican.**

### Phase_2:
Phase_2是一个循环，判断输入的六个数是否分别对应六次循环的变量值

![Phase_2](./img/Phase_2.png)

Phase_2调用了`read_six_numbers`函数，通过其汇编代码（此处省略）可以发现，该函数读取了输入的六个数字，按照输入顺序从栈的低地址排向高地址摆放

接下来我们看到了`cmpl    $0x0, (%rsp)`, 如果为负数就跳转至爆炸，说明输入的第一个数大于等于0，接下来将`%ebx`赋值1，`%rbp`为栈顶指针（当前指向输入的第一个数）

接下来jmp到循环体，进行6次循环，第i次循环时`%rbp`指向输入的第i个数，可以得出这六个数的递推关系：`num(i) = num(i-1) + i-1`

我们将num(1)设为1，则可以得到其中一种答案：

**1 2 4 7 11 16**

### Phase_3:
Phase_3是一个~~switch语句的跳转表~~，因为好像实现比较怪，但基本原理类似跳转表

![Phase_3](./img/Phase_3.png)

通过观察发现首先将一个地址给到了`%rsi`，后续引用了`sscanf`函数，因此我们知道第二个参数是一个字符串，能够告诉我们输入格式，于是我们使用

`x/s 0x555555558445`

查看输入格式

![Phase_3_sscanf](./img/Phase_3_sscanf.png)

所以我们知道了本题要输入两个整数，储存顺序由低地址向高地址

将第一个数与7进行无符号比较，如果大于则跳转至爆炸，于是我们可以得出输入的第一个数num1的范围[0, 7]

将`num1`放入`%eax`，通过后续对`%rdx`的使用方式，不难猜测这是一个`int`类型的数组，又因为num1有八种取值，通过分析可以猜测该数组长度为8，因此通过

`x/8dw 0x5555555581c0`

查看该数组的值

![Phase_3_array](./img/Phase_3_array.png)

我们假设输入的num1为0来得到一组答案

通过计算`%rdx+%rax`得到当前`%rax`的值，即对应跳转的地址，经计算num1为0时，其为0x0000555555556765，此时`%eax`内为0x10d，即269

接下来将num2与`%eax`比较，不相等则爆炸，相等则结束，故num1为0时，num2为269，因此其中一个答案为:

**0 269**

### Phase_4:
Phase_4是一个递归调用，要求输入输入值和递归后的返回值

Phase_4的汇编代码：

![Phase_4](./img/Phase_4.png)

func4的汇编代码：

![func4](./img/func4.png)

通过和Phase_3一样的方法发现本次同样要求输入两个整形数据，但是注意输入顺序不同，是从高地址向低地址输入

继续观察，发现其将`num2-2`与2进行无符号比较，如果不是小于等于就引爆炸弹，因此我们可以得到num2的范围：[2, 4]

接下来对func4的参数进行赋值，可以发现func4的参数应该有两个，第一个是6，第二个是num2，继续看Phase_3，发现最终要求num1和上方func4的返回值相同，否则爆炸

因此，我们当前目标就是求出`fun4(6, num2)`的返回值

对func4汇编代码分析：

我们假设`int func4(int n, int num)`

当`num=0`时，func4返回返回0，当`num=1`时，返回`num`

其它情况下将执行递归调用，一次`func4`调用了两次`func4`，我们先假设我们知道了这两次的返回值

第一次调用时第一个参数减1，将返回值加上`num`放入`%r12d`，即`%rax+%rbp`

第二次调用时第一个参数减2，将第二个参数重新设置为`num`，将返回值加上`%r12d`，作为本次`func4`的返回值，即`%eax=%eax+%r12d`

由此我们可以写出递归式：

**fun4(n, num) = func4(n-1, num) + func4(n-2, num) + num**

同样，假设我们输入的`num2`为2，我们由此递归式求`num1`，即func4(6, 2)，此时`func4(0, 2)=0, func4(1, 2)=2`，于是我们算出了：

**func4(6, 2) = 40**

因此，本题的一种答案为：

**40 2 ~~DrEvil~~**

### Phase_5:
Phase_5要求输入长度为6的字符串，其中这六个字符满足一些特殊条件

![Phase_5](./img/Phase_5.png)

通过前面几行，我们发现要求输入的字符串长度必须为6，否则跳转至爆炸

之后向`%rax`放入输入字符串的首地址，让`%rdi=%rax+6`，向`%rsi`中放入某一`int`类型数组`array`的首地址，通过`%edx`访问数组不同index的元素，对汇编代码分析，容易发现当前`%edx`的值为某一个字符ASCII码低4位的值，因此最大值为`1111`，转换为10进制为`15`，则数组长度为16

通过`x/16dw 0x5555555581e0`查看array：

![Phase_5_array](./img/Phase_5_array.png)

继续分析，发现这部分通过循环遍历了字符串的每个字符，并将每个字符低四位作为index的array的值加给`%ecx`，最终要求`%ecx`的值为`0x2b`，即43

其中一种通过array的6个值相加得到43的方法为:`2+10+6+1+12+12`，对应的index为:`0 1 2 3 4 4`, 故六个字符的ASCII码的低四位依次为`0000 0001 0010 0011 0100 0100`，查ASCII码表，得出其中一个可行的答案为：

**pabcdd**

### Phase_6:
Phase_6是一个链表，要求按输入的序号重构链表，使链表内的值满足某一关系

![Phase_6](./img/Phase_6.png)

(由于内容太长省略最后复原栈的内容)