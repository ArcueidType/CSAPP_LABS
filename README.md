# CSAPP Lab1 DataLab

## 解题思路

### 1.bitXor

本题要求使用`~`和`&`来达到`^`的效果

根据离散数学的基础知识, `x ^ y = ~((x&y)|(~x&~y)) = ~(x&y)&~(~x&~y)`, 所以本题只要`return ~(x&y)&~(~x&~y)`即可

代码:
```C
int bitXor(int x, int y) {
  return ~(x&y)&~(~x&~y);
}
```

### 2.tmin

本题要求函数返回二进制补码表示的整型数据的最小值tmin

整型数据有32位, 最小值为最高位（即符号位）为1, 其它位均为0，故我们只需将1左移31位到符号位即可

代码: 
```C
int tmin(void) {
  return 1<<31;
}
```

### 3.isTmax

本题要求判断一个数`x`是否为二进制补码整型数据的最大值`Tmax(0x7fffffff)`, 如果是则返回1, 否则返回0

要判断一个数是否是`int`的最大值，我们可以利用溢出这一特性, 即`Tmax+1 = Tmin(0x80000000)`

而且`Tmax+Tmin = 0xffffffff`, 所以我们就得到了`2Tmax+1 = 0xffffffff`, `~0xffffffff = 0`, `!0 = 1`

通过这一系列操作, 我们就可以由`Tmax`得到1

但是这是不对的, 因为我们还没有考虑没有溢出的情况下也符合上述等式的值

通过解方程组`2x+1 = 0xffffffff`, 可以得到`x = 0xffffffff`

我们不难发现, 这两个值在进行上述计算中, `x+1`的值有所不同, 我们暂时记`i = x+1`, 当`x = 0x7fffffff`时, `i = 0x80000000`, 

而当`x = 0xffffffff`时, `i = 0`, 所以我们只需要将`~(2Tmax+1)`的值先加上`!i`再取`!`, 这样当`x = 0xffffffff`时,最后结果就会变为`!1 = 0`, 

而`Tmax`的情况不受影响, 于是我们就排除了这种情况

代码: 
```C
int isTmax(int x) {
  int i=x+1;
  x=x+i;
  x=~x;
  x=x+!i;
  return !x;
}
```

### 4.allOddBits

本题要求如果`x`的奇数位都是1, 则返回1, 否则返回0（位从0到31）

既然本题只需要判断奇数位是否全是1, 和偶数位无关, 所以我们可以把偶数位全部变成1, 这样只需要判断偶数位全变为1后的`t`是不是全1的数即可

判断的方法即为`!(~t)`

因为我们最多只能使用八位的常数, 所以我们需要通过一些移位操作来达到让32位的`int`的所有偶数位变为1, 

方法即为`t=x|(0x55|(0x55<<8)|(0x55<<16)|(0x55<<24))`

代码: 
```C
int allOddBits(int x) {
  int t=x|(0x55|(0x55<<8)|(0x55<<16)|(0x55<<24));
  return !(~t);
}
```

### 5.negate

本题要返回`x`的相反数

利用简单的公式`x+~x = -1`我们可以得到`-x = ~x+1`

代码:
```C
int negate(int x) {
  return ~x+1;
}
```